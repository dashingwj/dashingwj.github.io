{"meta":{"title":"Paperwjun","subtitle":null,"description":"我的论文怎么这么难","author":"Paperwjun","url":"https://paperwj.top"},"pages":[{"title":"","date":"2020-02-15T07:55:24.166Z","updated":"2020-02-15T07:39:24.399Z","comments":true,"path":"404/index.html","permalink":"https://paperwj.top/404/index.html","excerpt":"","text":"登录页面 用户名 密码 忘记密码？"},{"title":"","date":"2020-02-15T07:55:13.155Z","updated":"2020-02-15T07:39:56.216Z","comments":true,"path":"404/login.js","permalink":"https://paperwj.top/404/login.js","excerpt":"","text":"/** * Created by Kay on 2016/3/8. */ function login() { var username = document.getElementById(\"username\"); var pass = document.getElementById(\"password\"); if (username.value == \"\") { alert(\"请输入用户名\"); } else if (pass.value == \"\") { alert(\"请输入密码\"); } else if(username.value == \"admin\" && pass.value == \"123456\"){ window.location.href=\"welcome.html\"; } else { alert(\"请输入正确的用户名和密码！\") } }"},{"title":"","date":"2020-02-15T07:55:13.139Z","updated":"2020-02-15T07:41:14.201Z","comments":true,"path":"404/login.css","permalink":"https://paperwj.top/404/login.css","excerpt":"","text":"body { background-image: url(\"images/login/loginBac.jpg\");; background-size: 100%; background-repeat: no-repeat; } #login_frame { width: 400px; height: 260px; padding: 13px; position: absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -200px; background-color: rgba(240, 255, 255, 0.5); border-radius: 10px; text-align: center; } form p > * { display: inline-block; vertical-align: middle; } #image_logo { margin-top: 22px; } .label_input { font-size: 14px; font-family: 宋体; width: 65px; height: 28px; line-height: 28px; text-align: center; color: white; background-color: #3CD8FF; border-top-left-radius: 5px; border-bottom-left-radius: 5px; } .text_field { width: 278px; height: 28px; border-top-right-radius: 5px; border-bottom-right-radius: 5px; border: 0; } #btn_login { font-size: 14px; font-family: 宋体; width: 120px; height: 28px; line-height: 28px; text-align: center; color: white; background-color: #3BD9FF; border-radius: 6px; border: 0; float: left; } #forget_pwd { font-size: 12px; color: white; text-decoration: none; position: relative; float: right; top: 5px; } #forget_pwd:hover { color: blue; text-decoration: underline; } #login_control { padding: 0 28px; }"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-28T05:05:51.669Z","comments":false,"path":"about/index.html","permalink":"https://paperwj.top/about/index.html","excerpt":"","text":"[Paper-wjun] 与&nbsp; Paperwjun&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-01-28T10:41:03.977Z","comments":false,"path":"bangumi/index.html","permalink":"https://paperwj.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"comment/index.html","permalink":"https://paperwj.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"donate/index.html","permalink":"https://paperwj.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-01-30T12:25:15.747Z","comments":false,"path":"lab/index.html","permalink":"https://paperwj.top/lab/index.html","excerpt":"","text":"个人简历紧张制作中….","keywords":"简历"},{"title":"music","date":"2020-01-01T15:14:28.000Z","updated":"2020-01-28T03:01:34.351Z","comments":false,"path":"music/index.html","permalink":"https://paperwj.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"https://paperwj.top/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"https://paperwj.top/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-30T12:24:39.020Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://paperwj.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"https://paperwj.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-15T08:29:04.207Z","comments":false,"path":"client/index.html","permalink":"https://paperwj.top/client/index.html","excerpt":"","text":"登录传送门","keywords":"神秘空间"},{"title":"links","date":"2019-12-19T15:11:06.000Z","updated":"2020-02-27T14:50:56.854Z","comments":true,"path":"links/index.html","permalink":"https://paperwj.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/悦读/index.html","permalink":"https://paperwj.top/tags/悦读/index.html","excerpt":"","text":""},{"title":"book","date":"2020-01-20T15:11:06.000Z","updated":"2020-01-30T12:08:55.402Z","comments":true,"path":"tags/藏书/index.html","permalink":"https://paperwj.top/tags/藏书/index.html","excerpt":"","text":"","keywords":"藏书阁"},{"title":"photo","date":"2020-01-10T14:14:16.000Z","updated":"2020-02-03T07:38:21.034Z","comments":false,"path":"tags/图集/index.html","permalink":"https://paperwj.top/tags/图集/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"Hadoop序列化自定义","slug":"Hadoop序列化自定义","date":"2020-02-29T12:00:00.000Z","updated":"2020-02-29T13:56:29.514Z","comments":true,"path":"2020/02/29/Hadoop序列化自定义/","link":"","permalink":"https://paperwj.top/2020/02/29/Hadoop序列化自定义/","excerpt":"","text":"曾经的文章介绍过Hadoop中的数据类型与Java中的基本数据类型的区别与联系，在实际需求时Hadoop提供的数据类型往往是不够用的，因此文本着重解决这个问题，有关Hadoop序列化的自定义。本文需要有一定的MapReduce基础 一、序列化 什么是序列化？ 将结构化对象转换成字节流以便于进行网络传输或写入持久存储的过程。 内存对象 &gt;&gt; 字节序列 什么是反序列化？ 将字节流转换为一系列结构化对象的过程。 磁盘的持久化数据 &gt;&gt; 内存对象 二、为什么要序列化序列化可以储存“活的”对象，可以将“活的”对象发送到远程计算机 三、Hadoop的序列化Java基本数据类型与Hadoop数据类型的对比 为什么Hadoop不沿用java的序列化 Java的序列化是一个重量级框架（Serializable），对象被序列化后，会附加很多额外信息，不便于在网络高效传输 Hadoop序列化特点 紧凑：高效使用储存空间 快速：读写数据的额外开销小 可拓展：随着通信协议的升级而升级 互操作：支持多种语言的交互 四、如何实现Hadoop序列化的自定义以下是Hadoop中的IongWritable源码 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.apache.hadoop.io; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import org.apache.hadoop.classification.InterfaceAudience.Public; import org.apache.hadoop.classification.InterfaceStability.Stable; @Public @Stable public class LongWritable implements WritableComparable&lt;LongWritable&gt; { private long value; public LongWritable() { } public LongWritable(long value) { this.set(value); } public void set(long value) { this.value = value; } public long get() { return this.value; } public void readFields(DataInput in) throws IOException { this.value = in.readLong(); } public void write(DataOutput out) throws IOException { out.writeLong(this.value); } public boolean equals(Object o) { if (!(o instanceof LongWritable)) { return false; } else { LongWritable other = (LongWritable)o; return this.value == other.value; } } public int hashCode() { return (int)this.value; } public int compareTo(LongWritable o) { long thisValue = this.value; long thatValue = o.value; return thisValue &lt; thatValue ? -1 : (thisValue == thatValue ? 0 : 1); } public String toString() { return Long.toString(this.value); } static { WritableComparator.define(LongWritable.class, new LongWritable.Comparator()); } public static class DecreasingComparator extends LongWritable.Comparator { public DecreasingComparator() { } public int compare(WritableComparable a, WritableComparable b) { return super.compare(b, a); } public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) { return super.compare(b2, s2, l2, b1, s1, l1); } } public static class Comparator extends WritableComparator { public Comparator() { super(LongWritable.class); } public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) { long thisValue = readLong(b1, s1); long thatValue = readLong(b2, s2); return thisValue &lt; thatValue ? -1 : (thisValue == thatValue ? 0 : 1); } } } 接口WritableComparable源码如下 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.apache.hadoop.io; import org.apache.hadoop.classification.InterfaceAudience.Public; import org.apache.hadoop.classification.InterfaceStability.Stable; @Public @Stable public interface WritableComparable&lt;T&gt; extends Writable, Comparable&lt;T&gt; { } 根据上述源码可以看出自定义的序列化类型需要实现如下几步 必须实现Writable接口 LongWritable因可能放在key排序，这是MapReduce框架中的Shuffle决定的，因此需要实现Comparable接口，从它的源码发现其实也继承了Writable、Comparable接口 反序列化时，需要反射调用空参构造函数，所以需要有空参构造 重写序列化方法 重写发序列化方法 注意：序列化与反序列化时顺序必须完全一致 把结果显示在文件中，则需要重写toString()方法，从而实现自定义的输出样式 五、实际案例这是我随便写的不同职业的最低薪资与最高薪资 程序员 6000 20000 教师 3000 8000 搬砖 10000 20000 教师 4000 8000 需求是实现各职业平均最低薪资、最高薪资以及职业内部的薪资差，理想的输出结果应该为 程序员 6000 20000 18000 通过分析，Hadoop已有的序列化类型无法满足这个需求，因此我们需要自定义Bean对象 1.实现Writable接口，空参构造分析可得Bean对象至少需要最低薪资、最高薪资和薪资差这三个属性 import org.apache.hadoop.io.Writable; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; public class Bean implements Writable { private int maxSalary; private int minSalary; private int spacing; //空参构造 Bean(){ super(); } public int getMaxSalary(){ return maxSalary; } public int getMinSalary(){ return minSalary; } public void setMaxSalary(int maxSalary){ this.maxSalary = maxSalary; } public void setMinSalary(int minSalary){ this.minSalary = minSalary; } public void setSpacing(){ this.spacing = maxSalary - minSalary; } public void write(DataOutput dataOutput) throws IOException { } public void readFields(DataInput dataInput) throws IOException { } } 2.重写序列化方法固定写法 //重写序列化方法 public void write(DataOutput dataOutput) throws IOException { dataOutput.writeInt(maxSalary); dataOutput.writeInt(minSalary); dataOutput.writeInt(spacing); } 3.重写反序列化方法需要注意的是反序列方法写法虽然固定，但是顺序必须与序列化方法的顺序一致【类似队列的性质，先进先出】 //重写反序列化方法 public void readFields(DataInput dataInput) throws IOException { maxSalary = dataInput.readInt(); minSalary = dataInput.readInt(); spacing = dataInput.readInt(); } 4.重写toString()方法根据理想的输出情况来重写toString()方法 //重写toString() @Override public String toString() { return maxSalary + &quot;\\t&quot; + minSalary + &quot;\\t&quot; + spacing; } 这样自定义的序列就写好了，下面我们来实现上述需求，和曾经的文章几乎一样，因此下面代码不写注释，可参照文章开头的链接 5.Map阶段package MapReduce; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; public class CountMap extends Mapper&lt;LongWritable, Text, Text, Bean&gt; { private Text k = new Text(); private Bean v = new Bean(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); String[] info = line.split(&quot; &quot;); k.set(info[0]); v.setMinSalary(Integer.parseInt(info[1])); v.setMaxSalary(Integer.parseInt(info[2])); context.write(k, v); } } 这里解释一下和以前写的代码不同之处，我将new的对象放在了map()方法之外，🤔🤔🤔考虑到map()方法是一行调用一次，曾经的方法意味着每行都至少需要new两个对象，为了遵守MapReduce的哲学就把它放外面。 6.Reduce阶段package MapReduce; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; public class CountReduce extends Reducer&lt;Text, Bean, Text, Bean&gt; { private Bean v = new Bean(); @Override protected void reduce(Text key, Iterable&lt;Bean&gt; values, Context context) throws IOException, InterruptedException { int sumMaxSalary = 0; int sumMinSalary = 0; int length = 0; for (Bean value : values){ length += 1; sumMaxSalary += value.getMaxSalary(); sumMinSalary += value.getMinSalary(); } v.setMaxSalary(sumMaxSalary/length); v.setMinSalary(sumMinSalary/length); v.setSpacing(); context.write(key, v); } } 7.Driver阶段package MapReduce; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import java.io.IOException; public class CountDriver { public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException { Job job = Job.getInstance(); job.setJarByClass(CountDriver.class); job.setMapperClass(CountMap.class); job.setReducerClass(CountReduce.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Bean.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Bean.class); FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } } 8.最终的运行结果 最近在准备一家科技公司的大数据开发助理的面试，希望一切顺利😄😄😄","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"LeetCode题目精选","slug":"LeetCode题目精选","date":"2020-02-29T12:00:00.000Z","updated":"2020-03-08T13:43:44.122Z","comments":true,"path":"2020/02/29/LeetCode题目精选/","link":"","permalink":"https://paperwj.top/2020/02/29/LeetCode题目精选/","excerpt":"","text":"LeetCode题目精选1. 两数之和链接：https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题解： class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } throw new IllegalArgumentException(&quot;No two sum solution&quot;); } } 2.爬楼梯链接：https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 题解： public class Solution { public int climbStairs(int n) { if (n == 1) { return 1; } int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } } 3. 翻转二叉树链接：https://leetcode-cn.com/problems/invert-binary-tree/ 翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 题解： public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode right = invertTree(root.right); TreeNode left = invertTree(root.left); root.left = right; root.right = left; return root; } 4. 反转链表链接：https://leetcode-cn.com/problems/reverse-linked-list/ 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解： public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; } 5. LRU缓存机制链接：https://leetcode-cn.com/problems/lru-cache/ 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 题解： class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;{ private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) { return size() &gt; capacity; } } /** * LRUCache 对象会以如下语句构造和调用: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 6. 最长回文子串链接：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 题解： public String longestPalindrome(String s) { if (s == null || s.length() &lt; 1) return &quot;&quot;; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } private int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) { L--; R++; } return R - L - 1; } 7. 有效的括号链接：https://leetcode-cn.com/problems/valid-parentheses/ 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 1. 左括号必须用相同类型的右括号闭合。 2. 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true 题解： class Solution { // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() { this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(&#39;)&#39;, &#39;(&#39;); this.mappings.put(&#39;}&#39;, &#39;{&#39;); this.mappings.put(&#39;]&#39;, &#39;[&#39;); } public boolean isValid(String s) { // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) { // Get the top element of the stack. If the stack is empty, set a dummy value of &#39;#&#39; char topElement = stack.empty() ? &#39;#&#39; : stack.pop(); // If the mapping for this bracket doesn&#39;t match the stack&#39;s top element, return false. if (topElement != this.mappings.get(c)) { return false; } } else { // If it was an opening bracket, push to the stack. stack.push(c); } } // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); } } 8. 数组中的第K个最大元素链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/ 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题解： import java.util.Random; class Solution { int [] nums; public void swap(int a, int b) { int tmp = this.nums[a]; this.nums[a] = this.nums[b]; this.nums[b] = tmp; } public int partition(int left, int right, int pivot_index) { int pivot = this.nums[pivot_index]; // 1. move pivot to end swap(pivot_index, right); int store_index = left; // 2. move all smaller elements to the left for (int i = left; i &lt;= right; i++) { if (this.nums[i] &lt; pivot) { swap(store_index, i); store_index++; } } // 3. move pivot to its final place swap(store_index, right); return store_index; } public int quickselect(int left, int right, int k_smallest) { /* Returns the k-th smallest element of list within left..right. */ if (left == right) // If the list contains only one element, return this.nums[left]; // return that element // select a random pivot_index Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); pivot_index = partition(left, right, pivot_index); // the pivot is on (N - k)th smallest position if (k_smallest == pivot_index) return this.nums[k_smallest]; // go left side else if (k_smallest &lt; pivot_index) return quickselect(left, pivot_index - 1, k_smallest); // go right side return quickselect(pivot_index + 1, right, k_smallest); } public int findKthLargest(int[] nums, int k) { this.nums = nums; int size = nums.length; // kth largest is (N - k)th smallest return quickselect(0, size - 1, size - k); } } 9. 实现 Trie (前缀树)实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&quot;apple&quot;); trie.search(&quot;apple&quot;); // 返回 true trie.search(&quot;app&quot;); // 返回 false trie.startsWith(&quot;app&quot;); // 返回 true trie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 题解： class Trie { private TrieNode root; public Trie() { root = new TrieNode(); } // Inserts a word into the trie. public void insert(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) { node.put(currentChar, new TrieNode()); } node = node.get(currentChar); } node.setEnd(); } // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char curLetter = word.charAt(i); if (node.containsKey(curLetter)) { node = node.get(curLetter); } else { return null; } } return node; } // Returns if the word is in the trie. public boolean search(String word) { TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); } } 10. 编辑距离链接：https://leetcode-cn.com/problems/edit-distance/ 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 1. 插入一个字符 2. 删除一个字符 3. 替换一个字符 示例 1: 输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; 输出: 3 解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;) rorse -&gt; rose (删除 &#39;r&#39;) rose -&gt; ros (删除 &#39;e&#39;) 示例 2: 输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot; 输出: 5 解释: intention -&gt; inention (删除 &#39;t&#39;) inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;) enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;) exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;) exection -&gt; execution (插入 &#39;u&#39;) 题解： class Solution { public int minDistance(String word1, String word2) { int n = word1.length(); int m = word2.length(); // if one of the strings is empty if (n * m == 0) return n + m; // array to store the convertion history int [][] d = new int[n + 1][m + 1]; // init boundaries for (int i = 0; i &lt; n + 1; i++) { d[i][0] = i; } for (int j = 0; j &lt; m + 1; j++) { d[0][j] = j; } // DP compute for (int i = 1; i &lt; n + 1; i++) { for (int j = 1; j &lt; m + 1; j++) { int left = d[i - 1][j] + 1; int down = d[i][j - 1] + 1; int left_down = d[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) left_down += 1; d[i][j] = Math.min(left, Math.min(down, left_down)); } } return d[n][m]; } } 整理自尚硅谷大数据2.27公开课面试宝典","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"Python面向对象编程","slug":"Python面向对象","date":"2020-02-16T15:45:01.000Z","updated":"2020-02-17T06:08:47.258Z","comments":true,"path":"2020/02/16/Python面向对象/","link":"","permalink":"https://paperwj.top/2020/02/16/Python面向对象/","excerpt":"","text":"一、基本需求 定制一个计时器的类 start和stop方法表示启动计时和停止计时 假设计时器对象t1，print(t1)和直接调用t1均显示结果 当计时器未启动或已停止计时，调用stop方法会给予温馨提示 两个计时器对象可以进行相加或相减（获取两次计时的和或者差） 二、需求分析1.定制一个计时器的类class MyTimer: pass 2.start和stop方法表示启动计时和停止计时Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。Python 提供了time 模块可以用于格式化日期和时间。其中time模块中的localtime()方法可以获取当前时间并以元组的形式返回，Python用一个元组装起来的9组数字处理时间格式如下： import time as t class MyTimer: def start(self): self.start = t.localtime() print(&quot;开始计时...&quot;) def stop(self): self.stop = t.localtime() print(&quot;计时结束...&quot;) 3.假设计时器对象t1，print(t1)和直接调用t1均显示结果首先肯定是实现计算start和stop之间的差值，因此定义一个函数用于计算，有上述可知localtime()返回的是一个元组，因此可以通过索引的方式依次计算差值 实现直接调用t1显示结果，当我们直接调用t1或者打印对象时会得到对象的内存地址 &lt;__main__.MyTimer object at 0x000001F853F7A1D0&gt; 这里就需要请出python魔法方法__str__和__repr__，这两个方法都是用于显示的，要说区别就只能理解为__str__面向用户，__repr__面向开发者，因此我们可以重写__str__方法用于返回时间差值 import time as t class MyTimer: def __init__(self): self.start = 0 self.stop = 0 self.lasted = [] def __str__(self): return str(self.lasted) #开始计时 def start(self): self.start = t.localtime() print(&quot;开始计时...&quot;) #结束计时 def stop(self): self.stop = t.localtime() self.__cal() print(&quot;计时结束...&quot;) #计算差值 def __cal(self): for index in range(6): self.lasted.append(self.stop[index] - self.start[index]) if __name__ == &#39;__main__&#39;: t1 = MyTimer() t1.start() t.sleep(1) #程序暂停1s t1.stop() print(t1) 运行的时候会报TypeError（一个大坑）…先考虑几秒 Traceback (most recent call last): File &quot;E:/Pycharm/Project/Note/MyTimer.py&quot;, line 30, in &lt;module&gt; t1.start() TypeError: &#39;int&#39; object is not callable 说我的t1.start()有错误并提示int对象不能被调用，这是什么原因呢？？？是因为类的属性名与方法名一样了，当我们调用方法时会被属性覆盖，因此会显示int对象不能被调用，只需要将属性名修改即可[start-&gt;begin;stop-&gt;end] 开始计时... 计时结束... [0, 0, 0, 0, 0, 1] 4.当计时器未启动或已停止计时，调用stop方法会给予温馨提示考虑到构造函数时begin和end都为0，因此可以在stop()方法里面添加判断begin是否为0即可，并做了一些简单的处理让上面的结果更加易读 import time as t class MyTimer: def __init__(self): self.begin = 0 self.end = 0 self.lasted = [] self.unit = [&#39;年&#39;,&#39;月&#39;,&#39;天&#39;,&#39;小时&#39;,&#39;分钟&#39;,&#39;秒&#39;] self.prompt = &quot;未开始计时&quot; def __str__(self): return self.prompt #开始计时 def start(self): self.begin = t.localtime() self.prompt = &quot;请先调用stop()停止结束&quot; #防止开始后不结束，直接调用t1 print(&quot;开始计时...&quot;) #结束计时 def stop(self): if not self.begin: #非0即真 print(&quot;请先调用start()开始计时&quot;) else: self.end = t.localtime() self.__cal() print(&quot;计时结束...&quot;) #计算差值 def __cal(self): self.lasted = [] #清一下，就是想清 self.prompt = &quot;总共运行了&quot; for index in range(6): self.lasted.append(self.end[index] - self.begin[index]) if self.lasted[index]: #非0即真，筛选lasted中的0元素并添加单位 self.prompt += (str(self.lasted[index])+self.unit[index]) #归零 self.begin = 0 self.end = 0 if __name__ == &#39;__main__&#39;: t1 = MyTimer() t1.start() t.sleep(1) t1.stop() print(t1) 我发现针对这个需求的调试Pycharm真的没有IDLE好用 5.两个计时器对象可以进行相加或相减python中万物皆对象，即使是简单的1+1也是对象之间的操作，会调用int对象中的__add__()方法，因此我们可以重新定义__add__()方法来实现类似C++中的运算符的重载 def __add__(self, other): #用一下就回收了，随便起个名字吧 prompt = &quot;总共运行了&quot; result = [] for index in range(6): result.append(self.lasted[index] + other.lasted[index]) if result[index]: prompt += (str(result[index])+self.unit[index]) return prompt 三、IDLE演示最终代码如下 import time as t class MyTimer: def __init__(self): self.begin = 0 self.end = 0 self.lasted = [] self.unit = [&#39;年&#39;,&#39;月&#39;,&#39;天&#39;,&#39;小时&#39;,&#39;分钟&#39;,&#39;秒&#39;] self.prompt = &quot;未开始计时&quot; def __str__(self): return self.prompt def __add__(self, other): #用一下就回收了，随便起个名字吧 prompt = &quot;总共运行了&quot; result = [] for index in range(6): result.append(self.lasted[index] + other.lasted[index]) if result[index]: prompt += (str(result[index])+self.unit[index]) return prompt #开始计时 def start(self): self.begin = t.localtime() self.prompt = &quot;请先调用stop()停止结束&quot; #防止开始后不结束，直接调用t1 print(&quot;开始计时...&quot;) #结束计时 def stop(self): if not self.begin: #非0即真 print(&quot;请先调用start()开始计时&quot;) else: self.end = t.localtime() self.__cal() print(&quot;计时结束...&quot;) #计算差值 def __cal(self): self.lasted = [] #清一下，就是想清 self.prompt = &quot;总共运行了&quot; for index in range(6): self.lasted.append(self.end[index] - self.begin[index]) if self.lasted[index]: #非0即真，筛选lasted中的0元素并添加单位 self.prompt += (str(self.lasted[index])+self.unit[index]) #归零 self.begin = 0 self.end = 0 演示结果如下： 为什么会有负数呢？？？比如 begin: 2020年2月16日20时10分00秒 end: 2021年1月17日21时9分50秒 根据程序定义的方法结果应该是 1年-1月1天1小时-1分钟50秒 因此我们需要将其转换为正常人看得懂的结果 11月1天59分钟50秒 小学减法算式告诉我们个位不够向十位借一，因此可以针对self.lasted后序遍历，若为负数则向前借一直到self.lasted列表元素全部为非负数即可[注：一年365天，一月30天不考虑闰年，月大月小等因素] import time as t class MyTimer: def __init__(self): self.begin = 0 self.end = 0 self.lasted = [] self.unit = [&#39;年&#39;,&#39;月&#39;,&#39;天&#39;,&#39;小时&#39;,&#39;分钟&#39;,&#39;秒&#39;] self.prompt = &quot;未开始计时&quot; def __str__(self): return self.prompt def __repr__(self): return self.prompt def __add__(self, other): #用一下就回收了，随便起个名字吧 prompt = &quot;总共运行了&quot; result = [] for index in range(6): result.append(self.lasted[index] + other.lasted[index]) if result[index]: prompt += (str(result[index])+self.unit[index]) return prompt #开始计时 def start(self): self.begin = t.localtime() self.prompt = &quot;请先调用stop()停止结束&quot; #防止开始后不结束，直接调用t1 print(&quot;开始计时...&quot;) #结束计时 def stop(self): if not self.begin: #非0即真 print(&quot;请先调用start()开始计时&quot;) else: self.end = t.localtime() self.__cal() self.__sortOut() print(&quot;计时结束...&quot;) #计算差值 def __cal(self): self.lasted = [] #清一下，就是想清 for index in range(6): self.lasted.append(self.end[index] - self.begin[index]) #归零 self.begin = 0 self.end = 0 def __sortOut(self): while True: if self.lasted[5] &lt; 0: self.lasted[4] -= 1 self.lasted[5] += 60 if self.lasted[4] &lt; 0: self.lasted[3] -= 1 self.lasted[4] += 60 if self.lasted[3] &lt; 0: self.lasted[2] -= 1 self.lasted[3] += 24 if self.lasted[2] &lt; 0: self.lasted[1] -= 1 self.lasted[2] += 30 if self.lasted[1] &lt; 0: self.lasted[0] -= 1 self.lasted[1] += 365 if self.lasted[0] &lt; 0: print(&#39;检查数据&#39;) if self.lasted[0] &gt;= 0 and self.lasted[1] &gt;= 0 and self.lasted[2] &gt;= 0 and self.lasted[3] &gt;= 0 \\ and self.lasted[4] &gt;= 0 and self.lasted[5] &gt;= 0: break self.prompt = &quot;总共运行了&quot; for index in range(6): if self.lasted[index]: #非0即真 self.prompt += (str(self.lasted[index]) + self.unit[index]) 整理自《零基础入门学习Python》（小甲鱼）","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"KNN算法","slug":"KNN算法","date":"2020-02-12T03:45:01.000Z","updated":"2020-02-12T12:30:47.603Z","comments":true,"path":"2020/02/12/KNN算法/","link":"","permalink":"https://paperwj.top/2020/02/12/KNN算法/","excerpt":"","text":"机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。 下面将介绍一种最简单的机器学习，你会发现机器学习其实没有那么神秘。 一、KNN简介KNN—— 邻近算法，或者说K最近邻(kNN，k-NearestNeighbor) ，最简单的机器学习算法没有之一，KNN 算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 kNN方法在类别决策时，只与极少量的相邻样本有关。由于kNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，kNN方法较其他方法更为适合。 二、算法思想解析1.核心思想物以类聚，人以群分 2.实现过程如下图 已知有两个含有“标签”的数据集class1和class2，它们在空间上的分布如图所示，现在我们需要知道新加入的绿色数据属于哪个数据集？？？根据KNN算法的核心思想，我们可以找这个数据“周围”的已知数据，看它们都属于什么数据集从而决定新数据的“标签”，那么就产生了如下问题 如何刻画“周围”的概念 应该找几个“周围”数据 最终如何识别从属关系 2.1如何刻画“周围”的概念我们可以通过距离的概念来刻画，选取一定数值范围内的距离来规定这些点是我的邻居或者说在我的周围，距离公式有很多，可以选取最常见的欧式距离即$$\\rho = \\sqrt{\\sum_{i=1}^n(x_i-y_i)^2}$$ 2.2 应该找几个“周围”数据这就是KNN中K的取值问题了，意思就是K个与我最近的邻居，这里的K选取如果过大会导致分类模糊，但过小又会受个例影响，波动较大 2.3 最终如何识别从属关系这就和我们选取的K有关了，如上图，当K=1时的意思就是我与离我最近的那个数据是同一类，那么我就是属于class2，当K=5时，这个时候我应该属于哪个类？？？最直接的我们可以按“少数服从多数”的思想来聚类，即我属于class1，但有个问题就是如果有两个class2离我特别特别近，这个时候按道理我应该是class2才对，因此我们需要用加权平均而不是算术平均来确定，直观上可以用距离的反比来计算权重。 三、手写数字识别1 收集数据来自MNIST有一组著名的手写数字数据集，其中拥有近10000张训练图片和近6000张测试图片，但是下载下来的是两组特殊格式的文件，因此编写了下面的代码来获取所有图片 from array import array import struct import os import png trainimg = &#39;./mnist/train-images.idx3-ubyte&#39; trainlabel = &#39;./mnist/train-labels.idx1-ubyte&#39; testimg = &#39;./mnist/t10k-images.idx3-ubyte&#39; testlabel = &#39;./mnist/t10k-labels.idx1-ubyte&#39; trainfolder = &#39;./mnist/train&#39; testfolder = &#39;./mnist/test&#39; if not os.path.exists(trainfolder): os.makedirs(trainfolder) if not os.path.exists(testfolder): os.makedirs(testfolder) # open(文件路径，读写格式)，用于打开一个文件，返回一个文件对象 # rb表示以二进制读模式打开文件 trimg = open(trainimg, &#39;rb&#39;) teimg = open(testimg, &#39;rb&#39;) trlab = open(trainlabel, &#39;rb&#39;) telab = open(testlabel, &#39;rb&#39;) # struct的用法这里不详述 struct.unpack(&quot;&gt;IIII&quot;, trimg.read(16)) struct.unpack(&quot;&gt;IIII&quot;, teimg.read(16)) struct.unpack(&quot;&gt;II&quot;, trlab.read(8)) struct.unpack(&quot;&gt;II&quot;, telab.read(8)) # array模块是Python中实现的一种高效的数组存储类型 # 所有数组成员都必须是同一种类型，在创建数组时就已经规定 # B表示无符号字节型，b表示有符号字节型 trimage = array(&quot;B&quot;, trimg.read()) teimage = array(&quot;B&quot;, teimg.read()) trlabel = array(&quot;b&quot;, trlab.read()) telabel = array(&quot;b&quot;, telab.read()) # close方法用于关闭一个已打开的文件，关闭后文件不能再进行读写操作 trimg.close() teimg.close() trlab.close() telab.close() # 为训练集和测试集各定义10个子文件夹，用于存放从0到9的所有数字，文件夹名分别为0-9 trainfolders = [os.path.join(trainfolder, str(i)) for i in range(10)] testfolders = [os.path.join(testfolder, str(i)) for i in range(10)] for dir in trainfolders: if not os.path.exists(dir): os.makedirs(dir) for dir in testfolders: if not os.path.exists(dir): os.makedirs(dir) # 开始保存训练图像数据 for (i, label) in enumerate(trlabel): filename = os.path.join(trainfolders[label], str(i) + &quot;.png&quot;) print(&quot;writing &quot; + filename) with open(filename, &quot;wb&quot;) as img: image = png.Writer(28, 28, greyscale=True) data = [trimage[(i * 28 * 28 + j * 28): (i * 28 * 28 + (j + 1) * 28)] for j in range(28)] image.write(img, data) # 开始保存测试图像数据 for (i, label) in enumerate(telabel): filename = os.path.join(testfolders[label], str(i) + &quot;.png&quot;) print(&quot;writing &quot; + filename) with open(filename, &quot;wb&quot;) as img: image = png.Writer(28, 28, greyscale=True) data = [teimage[(i * 28 * 28 + j * 28): (i * 28 * 28 + (j + 1) * 28)] for j in range(28)] image.write(img, data) 2 实现思路观察到图片颜色采用的是RGB模式一个像素点是一个三元组数值，因此将图片转换为灰度值并按照像素点以此读取灰度值保存为一个列表，这样我们可以将图片的数字作为字典的Key，并将所有相同Key的图片的灰度值列表append进一个大列表中作为字典的Value储存，根据上述的KNN基本思想，我们取出测试集的图片寻求合适的K并将算法得到的分类与图片本身的数字进行比较来求得算法的准确率，代码如下 &#39;&#39;&#39; 训练组个数：50000张图片 测试组个数：8000张图片 算法：KNN Date:2020/2/7 broing................ &#39;&#39;&#39; from PIL import Image import math import time def readImage(Path): #读取图片灰度值 ListOne = [] image = Image.open(Path).convert(&quot;1&quot;) #将图片转换为灰度值 width, height = image.size #获取图片宽、高 for i in range(width): for j in range(height): ListOne.append(image.getpixel((i, j))) #遍历所有像素点的灰度值并保存为一个列表 return ListOne def readData(): #读取所有训练图片灰度值并保存至dictImage for i in range(0,10): listAll = [] path_i = str(i) for j in range(1,5000): path_j = str(j) path = &#39;./Data/&#39;+path_i+&#39;/&#39;+path_i+&#39; (&#39;+path_j+&#39;).png&#39; #遍历训练组照片 listAll.append(readImage(path)) dictImage[path_i] = listAll #按文件夹名称分类保存训练组数据 def startTest(Path): #读取测试图片，通过KNN算法进行识别并返回识别的结果 test = readImage(Path) # 读取测试图片数据 reslut = {} # 存放与训练组比对的结果 for i in dictImage.keys(): # dictImage.keys()=[0,1,2,3,4,5,6,7,8,9] list = [] for j in dictImage[i]: # dictImage[i]=[[~],[~],~,[~]] sum = 0 for k in range(len(j)): # k=[0,0,0,255,~,0,0] sum += math.pow((test[k] - j[k]),2) list.append(int(math.sqrt(sum))) list.sort() reslut[i] = list[0] #找出最小“距离” key = &#39;0&#39; min = reslut[key] for i in reslut.keys(): if min &gt; reslut[i]: key = i min = reslut[i] return key #最小值对应的key即为识别结果 def getPro(): #批量识别测试组照片，并返回准确率 count = 0 #记录识别正确次数 Sum = 0 #记录识别次数 for i in range(0,10): path_i = str(i) for j in range(1,500): Sum += 1 path_j = str(j) path = &#39;./mnist/test/&#39;+path_i+&#39;/&#39;+path_i+&#39; (&#39;+path_j+&#39;).png&#39; #遍历测试组图片 testkey = startTest(path) if testkey == path_i: #判断识别结果是否正确 count += 1 return count/Sum #返回正确率 if __name__ == &#39;__main__&#39;: start = time.process_time() # 记录程序开始时间 dictImage = {} # 保存训练组数据 readData() # Pro = getPro() # print(&#39;准确率：&#39;,Pro) print(startTest(&#39;./Data/test.png&#39;)) end = time.process_time() print(&#39;Running time：%s S&#39; % (int(end - start))) 3 结果运行结果如下 非常不错的准确率，就是运行时间有点长，主要是数据太多，而我又是使用最笨的方法读取图片数据，有时间一定优化一下。 本文所有的代码、数据 点这个","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"元胞自动机","slug":"元胞自动机","date":"2020-02-03T04:00:00.000Z","updated":"2020-02-12T13:04:19.653Z","comments":true,"path":"2020/02/03/元胞自动机/","link":"","permalink":"https://paperwj.top/2020/02/03/元胞自动机/","excerpt":"","text":"一、元胞自动机概述1.通俗解释元胞自动机（cellular automata，CA） 是一种时间、空间、状态都离散，空间相互作用和时间因果关系为局部的网格动力学模型，具有模拟复杂系统时空演化过程的能力。 不同于一般的动力学模型，元胞自动机不是由严格定义的物理方程或函数确定，而是用一系列模型构造的规则构成。凡是满足这些规则的模型都可以算作是元胞自动机模型。因此，元胞自动机是一类模型的总称，或者说是一个方法框架。其特点是时间、空间、状态都离散，每个变量只取有限多个状态，且其状态改变的规则在时间和空间上都是局部的。 2.动力学分类元胞自动机的构建没有固定的数学公式，构成方式繁杂，变种很多，行为复杂。故其分类难度也较大，在 基于不同的出发点，元胞自动机可有多种分类，其中，最具影响力的当属S. Wolfram在80年代初做的基于动力学行为的元胞自动机分类： 平稳型 自任何初始状态开始，经过一定时间运行后，元胞空间趋于一个空间平稳的构形，这里空间平稳即指每一个元胞处于固定状态。不随时间变化而变化 周期型 经过一定时间运行后，元胞空间趋于一系列简单的固定结构（Stable Patterns）或周期结构（Perlodical Patterns)。由于这些结构可看作是一种滤波器（Filter），故可应用到图像处理的研究中 混沌型 自任何初始状态开始，经过一定时间运行后，元胞自动机表现出混沌的非周期行为，所生成的结构的统计特征不再变止，通常表现为分形分维特征 复杂型 出现复杂的局部结构，或者说是局部的混沌，其中有些会不断地传播 二、模拟森林火灾原理下面介绍一种平稳型的元胞自动机的应用，在现实世界中我们有以下概念： 时间 空间 物理法则 因元胞自动机具有模拟复杂系统时空演变的能力，因此我们基于此模拟森林火灾也有其特定的时间、空间、物理法则，下面我们制定属于这个世界的时间空间和物理法则。 定义世界 100x100方格的二维世界 定义元素 没着火的树 着火的树 空地 定义时间 CPU时间 定义法则 空地不会着火 没着火的树若四周每有一颗着火的树有一定概率会着火，概率会累加且上限为100% 着火三天的树会变成空地 三、逻辑实现First Of all 实现世界 Java定义100x100的二维数组 实现元素 没着火的树 —— 0 着火的树 —— 1 空地 —— 2 实现时间 遍历一次为现实世界的一个周期 实现法则 0 -&gt; 1：表示树着火了 1 -&gt; 2：表示着火三天的树变成空地【烧没了】 定义同阶状态矩阵来记录着火天数 What’more考虑到现实世界的森林覆盖率以及提及到的周围有燃烧的树会概率着火，因此我们需要一个自定义函数依概率生成二维数组和状态的改变（例如：25%的概率由0 -&gt; 1），根据Java提供的Random类我们可以自定义我们的随机函数 private static int customProbability(int Pro , int a , int b){ Random random = new Random(); if (random.nextInt(100) &lt; Pro){ return a; } else return b; } 因此我们可以基于customProbability()方法来初始化我们的世界 private static int[][] initializationWorld(int Pro){ //初始化世界 int[][] cellWorld = new int[100][100]; //初始化世界元素 for (int i = 0; i &lt; cellWorld.length; i++){ for (int j = 0; j&lt; cellWorld.length; j++){ cellWorld[i][j] = customProbability(Pro,0,2); } } return cellWorld; } 依概率随机给100*100的二维数组赋0【没着火的树】，2【空地】，同时我们还需要记录燃烧天数的状态矩阵，即同阶的全0二维数组 private static int[][] stateMatrix(){ int[][] stateMatrix = new int[100][100]; for (int i = 0; i &lt; stateMatrix.length; i++){ for (int j = 0; j&lt; stateMatrix.length; j++){ stateMatrix[i][j] = 0; } } return stateMatrix; } 为测试世界以及状态矩阵是否符合要求并未后面查看世界做准备，在这里提前写出查看当前世界的方法，即接收一个二维数组并输出 private static void outPut(int[][] Matrix){ for (int i=0; i&lt; Matrix.length;i++){ for (int j = 0 ; j&lt; Matrix.length;j++){ System.out.print(Matrix[i][j] + &quot; &quot;); } System.out.println(); } } 高潮就要到来…某一天的早晨这片森林的若干颗树意外着火的，即将上面已经初始化好的二维数组中的若干个0变成1，并在相同位置的状态矩阵加1表示开始燃烧 //随机点火，需要接收initializationWorld返回的世界,a表示失火树的个数 //这个方法有bug,有时间优化一下 //Matrix_1 初始化世界，Matrix_2 初始化状态矩阵 private static Map&lt;String,int[][]&gt; runFire(int[][] Matrix_1,int[][] Matrix_2, int a){ Random random = new Random(); Map&lt;String, int[][]&gt; result = new HashMap&lt;String, int[][]&gt;(); int count = 0; //随机找a颗没有着火的树并让它们着火 while (true){ int i = random.nextInt(100); int j = random.nextInt(100); if (Matrix_1[i][j] == 0){ Matrix_1[i][j] = 1; Matrix_2[i][j] += 1; count += 1; } if (count == a ) break; } result.put(&quot;世界矩阵&quot;,Matrix_1); result.put(&quot;状态矩阵&quot;,Matrix_2); return result; } 解释：这个方法设计之初考虑到需要返回世界矩阵和状态矩阵两个二维数组，同时还需要接收用户自定义燃烧颗，因此我用了Map这个数据结构，当时觉得自己怎么这么聪明^_^ 现在初始的树已经点着了，逻辑告诉我需要一个方法来告诉我们一颗没着火的树“上下左右”有多少颗着火的树，考虑到如果它是树就只有两种状态着火或者没着火，因此只需要一个方法接收4个布尔值并返回布尔值有多少个true或false private static int stateChangeNum(boolean a, boolean b, boolean c, boolean d){ int num = 0; boolean[] isTrue ={a,b,c,d}; for (boolean Num : isTrue){ if (Num){ num += 1; } } return num; } 到这里我们开始烧树了，即改变世界矩阵和状态矩阵 //基于runFire(initializationWorld(80,0,2),1000)矩阵开始改变状态 //Pro森林覆盖面积，即以此概率生成世界 //num初始燃烧树的个数 //year燃烧年数 private static int[][] /*void*/ stateChange(int Pro, int num, int year){ Map&lt;String, int[][]&gt; map =runFire(initializationWorld(Pro),stateMatrix(),num); int[][] worldMatrix = map.get(&quot;世界矩阵&quot;); int[][] stateMatrix = map.get(&quot;状态矩阵&quot;); System.out.println(&quot;==============初始世界==============&quot;); outPut(worldMatrix); for (int Year = 1; Year &lt;= year; Year++){ for (int i = 0; i &lt; worldMatrix.length; i++){ for (int j = 0; j&lt; worldMatrix.length; j++){ if (worldMatrix[i][j] == 1){ stateMatrix[i][j] += 1; if (stateMatrix[i][j] &gt; 3){ worldMatrix[i][j] = 2; } } if (worldMatrix[i][j] == 0){ try { boolean judge_1 = worldMatrix[i-1][j] == 1; boolean judge_2 = worldMatrix[i+1][j] == 1; boolean judge_3 = worldMatrix[i][j-1] == 1; boolean judge_4 = worldMatrix[i][j+1] == 1; int isTrueNum = stateChangeNum(judge_1,judge_2,judge_3,judge_4); if (judge_1 || judge_2|| judge_3 || judge_4){ worldMatrix[i][j] = customProbability(25 * isTrueNum, 1, 0); } } catch (Exception e){ //边界树假设永远不会着火 } } } } System.out.println(&quot;==============第&quot; + Year + &quot;年世界==============&quot;); outPut(worldMatrix); } return worldMatrix; //预留给GUI } 解释：有些小伙伴已经发现了这个方法有bug，那就是当处于边缘的树它最多只有三个邻居，这儿样的话这个方法可能会发生数组越界Exception，其实不难解决只需要单独加一个判断当数组下表有0的时候我们单独判断，但是，哈哈哈我已经写了三个for循环嵌套，还有n个if判断，虽然我的逻辑依然清晰，但是我懒，直接来个异常处理并假设边界树不会着火[着火了有人灭]，毕竟数学建模嘛怎么简单怎么来，还不许人写几个假设？？？ 考虑到封装，上面的所有方法我都用了private，是时候留一个公开的接口来启动程序 public static void start(int Pro, int num, int year){ stateChange(Pro,num,year); } Last But Not Least完整代码如下 package ForestFire; import java.util.HashMap; import java.util.Map; import java.util.Random; public class World { //初始化世界和元素 private static int[][] initializationWorld(int Pro){ //初始化世界 int[][] cellWorld = new int[100][100]; //初始化世界元素 for (int i = 0; i &lt; cellWorld.length; i++){ for (int j = 0; j&lt; cellWorld.length; j++){ cellWorld[i][j] = customProbability(Pro,0,2); } } return cellWorld; } //初始化状态矩阵 private static int[][] stateMatrix(){ int[][] stateMatrix = new int[100][100]; for (int i = 0; i &lt; stateMatrix.length; i++){ for (int j = 0; j&lt; stateMatrix.length; j++){ stateMatrix[i][j] = 0; } } return stateMatrix; } //自定义概率 private static int customProbability(int Pro , int a , int b){ Random random = new Random(); if (random.nextInt(100) &lt; Pro){ return a; } else return b; } //输出世界状态 private static void outPut(int[][] Matrix){ for (int i=0; i&lt; Matrix.length;i++){ for (int j = 0 ; j&lt; Matrix.length;j++){ System.out.print(Matrix[i][j] + &quot; &quot;); } System.out.println(); } } //随机点火，需要接收initializationWorld返回的世界,a表示失火树的个数 //这个方法有bug,有时间优化一下 //Matrix_1 初始化世界，Matrix_2 初始化状态矩阵 private static Map&lt;String,int[][]&gt; runFire(int[][] Matrix_1,int[][] Matrix_2, int a){ Random random = new Random(); Map&lt;String, int[][]&gt; result = new HashMap&lt;String, int[][]&gt;(); int count = 0; //随机找a颗没有着火的树并让它们着火 while (true){ int i = random.nextInt(100); int j = random.nextInt(100); if (Matrix_1[i][j] == 0){ Matrix_1[i][j] = 1; Matrix_2[i][j] += 1; count += 1; } if (count == a ) break; } result.put(&quot;世界矩阵&quot;,Matrix_1); result.put(&quot;状态矩阵&quot;,Matrix_2); return result; } //返回一棵树周围有多少个燃烧的树 private static int stateChangeNum(boolean a, boolean b, boolean c, boolean d){ int num = 0; boolean[] isTrue ={a,b,c,d}; for (boolean Num : isTrue){ if (Num){ num += 1; } } return num; } //基于runFire(initializationWorld(80,0,2),1000)矩阵开始改变状态 //Pro森林覆盖面积，即以此概率生成世界 //num初始燃烧树的个数 //year燃烧年数 private static int[][] /*void*/ stateChange(int Pro, int num, int year){ Map&lt;String, int[][]&gt; map =runFire(initializationWorld(Pro),stateMatrix(),num); int[][] worldMatrix = map.get(&quot;世界矩阵&quot;); int[][] stateMatrix = map.get(&quot;状态矩阵&quot;); System.out.println(&quot;==============初始世界==============&quot;); outPut(worldMatrix); for (int Year = 1; Year &lt;= year; Year++){ for (int i = 0; i &lt; worldMatrix.length; i++){ for (int j = 0; j&lt; worldMatrix.length; j++){ if (worldMatrix[i][j] == 1){ stateMatrix[i][j] += 1; if (stateMatrix[i][j] &gt; 3){ worldMatrix[i][j] = 2; } } if (worldMatrix[i][j] == 0){ try { boolean judge_1 = worldMatrix[i-1][j] == 1; boolean judge_2 = worldMatrix[i+1][j] == 1; boolean judge_3 = worldMatrix[i][j-1] == 1; boolean judge_4 = worldMatrix[i][j+1] == 1; int isTrueNum = stateChangeNum(judge_1,judge_2,judge_3,judge_4); if (judge_1 || judge_2|| judge_3 || judge_4){ worldMatrix[i][j] = customProbability(25 * isTrueNum, 1, 0); } } catch (Exception e){ //边界树假设永远不会着火 } } } } System.out.println(&quot;==============第&quot; + Year + &quot;年世界==============&quot;); outPut(worldMatrix); } return worldMatrix; //预留给GUI } public static void start(int Pro, int num, int year){ stateChange(Pro,num,year); } } 最后我打了jar包jar包在这里这个jar包会实时更新，不间断的完善这个类加入更多的注释，自定义世界等功能，最最重要的是预留了一个GUI数据的接口，接下来的时间我会学习Swing框架最终时间一个有界面的模拟森林，当然有大佬看见欢迎过来索要最新的jar包。 四、效果展示 说在前面：以下效果是基于Excel做的^_^效果视频点这里","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"资源分享","slug":"资源分享","date":"2020-02-01T03:45:01.000Z","updated":"2020-02-12T13:03:47.808Z","comments":true,"path":"2020/02/01/资源分享/","link":"","permalink":"https://paperwj.top/2020/02/01/资源分享/","excerpt":"","text":"Java相关 本人入坑的笔记 密码:cf1e 未完待续… Python相关 本人入坑的笔记 https://www.lanzous.com/i9alcah 未完待续… Hadoop相关 本人入坑的笔记 https://www.lanzous.com/i9albkb 未完待续…","categories":[{"name":"资源","slug":"资源","permalink":"https://paperwj.top/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"https://paperwj.top/categories/资源/"}]},{"title":"分布式并行编程框架-MapReduce","slug":"分布式并行编程框架—MapReduce","date":"2020-01-31T14:00:00.000Z","updated":"2020-02-01T04:29:07.669Z","comments":true,"path":"2020/01/31/分布式并行编程框架—MapReduce/","link":"","permalink":"https://paperwj.top/2020/01/31/分布式并行编程框架—MapReduce/","excerpt":"","text":"1、什么是MapReduce1.1 举个例子果园里有海量苹果，我们假设有三种颜色，红色、黄色、绿色，现在把苹果采摘完成了，并放到了一起，如下图所示 我们现在需要分别统计每种颜色的苹果的个数，怎么实现呢？ 我们可以找一个人，来完成这个工作，但是别忘了，我们面对的是海量的苹果，所以我们需要很多人来一起完成这个工作。也就是说，这海量的苹果被分成了若干份，每个人处理一份，如下图所示： 每个人只处理自己的那一份，他们的工作就是把自己分到的那份苹果，按照颜色进行分类，如下图所示： 有很多人都完成了自己那份工作，那还差了一步，就是按照颜色进行汇总，也就是如下图所示： 这样我们就统计了每个颜色的苹果的个数了。我们为什么要讲这个例子呢？其实这个例子就概括了什么是MapReduce。 1.2 什么是MapReduceMapreduce是一个分布式、运算程序的编程框架，把海量的数据，切分成若干个小份，每台服务器负责若干个小份，对数据进行运算。那么海量的数据就平均分配到若干台服务器上。MapReduce所处理的数据是放在HDFS之上的。Mapreduce核心功能是将用户编写的业务逻辑代码，并发运行在一个hadoop集群上。 2、MapReduce核心思想MapReduce实现的分布式的运算，程序往往需要分成至少2个阶段 第一个阶段的map task并发执行，完全并行运行，互不相干 第二个阶段的reduce task并发执行，互不相干，他们的数据依赖于所有maptask的输出 再拿上面例子来看一下： map task有若干个，每个map task处理一部分数据，对数据进行分类等操作，并得到一个结果数据，然后每个map task处理之后的数据，会被拿到reduce task端进行合并。所以简单来说: map task是用来处理每一小分数据 reduce task是用来合并map task成立之后的数据 3、MapReduce编码规范用户编写的程序分成三个部分：Mapper、Reducer和Driver 1）Mapper阶段 用户自定义的Mapper要继承自己的父类 Map Mapper的输入数据是KV对的形式（KV的类型可自定义） Mapper中的业务逻辑写在自定义map()方法中 Mapper的输出数据是KV对的形式（KV的类型可自定义） map task进程 对每一个&lt;K,V&gt;调用一次map()方法 2）Reducer阶段 用户自定义的Reducer要继承自己的父类Reducer Reducer的输入数据类型对应Mapper的输出数据类型，也是KV Reducer的业务逻辑写在自定义reduce()方法中 reduce task进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法 3）Driver阶段 整个程序需要一个Drvier来进行提交，提交的是一个描述了各种必要信息的job对象 4、MapReduce模拟示例现在我们来模拟上面的案例，通过如下代码生成一些苹果 import random f = open(&#39;AppleCount.txt&#39;,&#39;w&#39;) apple = [&#39;红 &#39;,&#39;黄 &#39;,&#39;蓝 &#39;,&#39;绿 &#39;,&#39;\\n&#39;] for i in range(1000): choice = random.randint(0,4) if choice == 0: f.write(apple[0]) if choice == 1: f.write(apple[1]) if choice == 2: f.write(apple[2]) if choice == 3: f.write(apple[3]) if choice == 4: f.write(apple[4]) f.close() 通过随机数0-4表示红、黄、蓝、绿四种颜色的苹果，并通过\\n换行，一行数据表示一个人的任务。 AppleCount.txt 部分数据如下 蓝 蓝 绿 红 蓝 蓝 黄 绿 红 蓝 红 红 黄 黄 蓝 蓝 红 蓝 红 绿 绿 蓝 黄 红 蓝 黄 红 蓝 绿 红 蓝 黄 黄 黄 蓝 红 蓝 黄 黄 黄 黄 红 黄 绿 绿 蓝 蓝 红 蓝 绿 黄 红 黄 绿 红 绿 黄 绿 红 绿 红 黄 黄 红 绿 蓝 蓝 下面开始开始实现逻辑 1）Mapper阶段逻辑默认配置好了hadoop的jar包，能上外网的可以添加依赖，我是内网所以配置的Libraries。jar包自取 自定义ApperMapper类继承Mapper类并复写map方法 package AppleCount; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; public class AppleMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;{ @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { super.map(key, value, context); } } [包不要导错了，看清楚是mapreduce的] Mapper&lt;LongWritable, Text, Text, IntWritable&gt; Mapper有四个参数分别是传入数据Key、传入数据Value、传出数据Key、传出数据Value，传入数据Key又称偏移值，仅记录每行数据的位置并无其他意思，传入数据Value根据上面所说即为一行数据，后三个数据类型需根据业务逻辑自行改变，注意：Java中的数据类型并不适用Hadoop，但其对应关系如下： Java类型 Hadoop Writable类型 boolean BooleanWritable byte ByteWritable int IntWritable float FloatWritable long LongWritable double DoubleWritable string Text map MapWritable array ArrayWritable 下面我们分析逻辑，首先Map端传入一行数据 绿 红 蓝 红 红 黄 黄 蓝 蓝 红 蓝 这是分给我的苹果，我需要做的仅仅是统计这一行不同颜色苹果的个数即可，传入的是Text类型，我们需要将其转换为string类型，注意到每个苹果是用空格割开，因此我们可以按空格对字符串进行切割得到没一个苹果 String[] line = value.toString().split(&quot; &quot;); 如何统计个数？？？ 遍历，我们可以遍历line里面的每一个苹果，把它的颜色作为Key，Value记为1表示一个苹果的意思，把这组KV对通过context传给Reduce端 for (String Line : line){ context.write(new Text(Line), new IntWritable(1)); } 我们可以写出Map端传出的KV对 &lt; 绿 , 1 &gt; &lt; 红 , 1 &gt; &lt; 蓝 , 1 &gt; &lt; 红 , 1 &gt; &lt; 红 , 1 &gt; &lt; 黄 , 1 &gt; &lt; 黄 , 1 &gt; &lt; 蓝 , 1 &gt; &lt; 蓝 , 1 &gt; &lt; 红 , 1 &gt; &lt; 蓝 , 1 &gt; 2）Reducer阶段逻辑其实在传入Reduce端之前会对其相同的Key进行一次整合，例如上面的会被整合为 &lt; 红 , [1,1,1,1] &gt; &lt; 黄 , [1,1] &gt; &lt; 蓝 , [1,1,1,1] &gt; &lt; 绿 , [1] &gt; 传入Reduce端是上面的KV对形势，那么Reduce类同理，自定义AppleReducer类并继承Reducer，复写reduce方法，同样Reducer也有四个参数，前面为接收Map端数据，那么应该保持一致，后面的两个参数为输出KV对数据类型，根据业务逻辑自定义。 package AppleCount; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; public class AppleReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { super.reduce(key, values, context); } } 下面分析reduce逻辑，在这里面其实已经达到业务要求，只需要统计Value有多少个1即可，因此可以遍历Value实现累加，注意这里的1的数据类型是IntWritable，因此我们可以申明一个count来计数直接输出即可。 int count = 0; for (IntWritable Values : values){ count += 1; } context.write(key, new IntWritable(count)); 3)Driver阶段逻辑至于Driver端可以说是一个模板，需要修改的地方注释以标出，完整代码如下： package AppleCount; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import java.io.IOException; public class AppleDriver { public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException { Job job = Job.getInstance(); job.setJarByClass(AppleDriver.class);//指出程序入口 job.setMapperClass(AppleMapper.class);//指出Mapper类 job.setMapOutputKeyClass(Text.class);//指出map输出key类型 job.setMapOutputValueClass(IntWritable.class);//指出map输出value类型 job.setReducerClass(AppleReducer.class);//指出Reducer类 job.setOutputKeyClass(Text.class);//指出reduce输出key类型 job.setOutputValueClass(IntWritable.class);//指出reduce输出value类型 FileInputFormat.addInputPath(job,new Path(&quot;/Data/AppleCount.txt&quot;));//数据存放路径 FileOutputFormat.setOutputPath(job,new Path(&quot;/Data/AppleCount&quot;));//结果存放路径 job.waitForCompletion(true); //启动程序 } } 注意：数据存放的路径及结果存放的路径是HDFS里的路径，不是本地，不是本地，不是本地 完整Mapper代码如下： package AppleCount; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; public class AppleMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;{ @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String[] line = value.toString().split(&quot; &quot;); for (String Line : line){ context.write(new Text(Line), new IntWritable(1)); } } } 完整Reducer代码如下： package AppleCount; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; public class AppleReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { int count = 0; for (IntWritable Values : values){ count += 1; } context.write(key, new IntWritable(count)); } } 最后配置一下Artifacts，打一个jar包，并记录程序入口的本地相对路径[右击AppleDrive选择Copy Reference] AppleCount.AppleDriver 需要删除jar包里META-INF文件夹里的MSFTSIG.RSA和MSFTSIG.SF，最后我们需要将jar包导入Linux系统中，将数据AppleCount上传到程序指定的HDFS路径，注意结果存放路径的文件夹在HDFS一定要不存在，不存在，不存在，程序会自己创建，然后就是上一篇博文的知识了，启动HDFS—上传文件，最后运行jar包，代码如下： hadoop jar /MapReduce/Blog.jar AppleCount.AppleDriver /MapReduce/Blog.jar是你jar包在Linux下的位置，当看到绿绿的successfully表示程序运行成功。 来到我们程序设定的结果存放路径我们可以看两个文件_SUCCESS日志文件，说明成功了，part文件存放我们的结果 可以用cat命令查看 hdfs dfs -cat /Data/AppleCount/p* 其最中结果如下[因为数据未清洗，可能会统计一些空格数量] 红 222 绿 194 蓝 190 黄 205 当然，说了这么多其实完全可以用word直接查找^_^,开个玩笑，例子很简单，主要了解原理懂得运用……[上述源码、数据、jar包这里自取(https://www.lanzous.com/i8ygv5e） 初学Hadoop博客仅为存放一些笔记，若能帮到你一丝万分荣幸，如有错误欢迎评论留言","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"分布式文件系统-HDFS","slug":"分布式文件系统—HDFS","date":"2020-01-30T04:00:00.000Z","updated":"2020-01-31T14:39:07.288Z","comments":true,"path":"2020/01/30/分布式文件系统—HDFS/","link":"","permalink":"https://paperwj.top/2020/01/30/分布式文件系统—HDFS/","excerpt":"","text":"一、前言实验环境仅用于个人学习使用且电脑配置有限，因此搭建伪分布式模式，即在单节点上启动NameNode、DataNode、SecondaryNameNode等进程，但操作、原理与完全分布式模式一样仅学习还是够用的。HDFS作为Hadoop两大重要组成部分之一，主要解决海量数据存储问题，详细信息点击这里哟！下面是我的实验环境（Hadoop大多运行在Linux系统下） 服务器：Centos 6 虚拟机：VMware Workstation Pro 13.0 SSH：MobaXterm PC：Win10 二、HDFS运行原理1.HDFS概念 HDFS，是 Hadoop Distribute File System 的简称，意为：Hadoop 分布式文件系统。是 Hadoop 核心组件之一。 HDFS解决的问题就是大数据的存储。它们是横跨在多台计算机上的存储系统。分布式文件系统在大数据时代有着广泛的应用前景，它们为存储和处理超大规模数据提供所需的扩展能力。 HDFS起源于Google的GFS论文（GFS，Mapreduce，BigTable为google的旧的三驾马车） 2.HDFS优缺点 优点 高容错性 适合大数据处理 可搭建在廉价的机器上 缺点 不适合低延迟数据访问 不适合大量小文件进行存储 不支持文件并发写入和文件随机修改 3.HDFS组成架构（重点）HDFS 采用 master/slave 架构。一般一个 HDFS 集群是有一个 Namenode 和一定数目的Datanode 组成。Namenode 是 HDFS 集群主节点，Datanode 是 HDFS 集群从节点，两种角色各司其职，共同协调完成分布式的文件存储服务。 Client：客户端 文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block 与NameNode交互，获取文件的位置信息 与DataNode交互，读取或者写入数据 提供一些命令来管理HDFS NameNode：名称节点。就是Master，它是一个主管、管理者、老大 存储元数据（内存中） 保存block与DataNode之间的映射关系 DataNode：数据节点。就是小弟。NameNode下达命令，DataNode执行实际的操作 存储文件内容（磁盘） 维护block ID到DataNode本地文件的映射关系 存储到本地Linux系统中 SecondaryNameNode：第二名称节点。NameNode的冷备份 主要解决EditLog不断增大的问题（下面会详细介绍） 3.1 Block大小​ HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数(dfs.blocksize)来规定，默认大小在hadoop2.x版本中是128M，老版本中是64M。HDFS的块设计成，其目的是为了最小化寻址开销。如果块设置得足够大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。因而，传输一个由多个块组成的文件的时间取决于磁盘传输速率。 3.2 副本机制​ 为了容错，文件的所有 block 都会有副本。每个文件的 block 大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目，副本系数可以在文件创建的时候指定，也可以在之后改变。 3.3 元数据​ 数据的描述信息，比如这个文件的路径，这个文件的副本数，每个副本保存在哪个DataNode上，就相当于真真正正的一个人，他有一些信息：身高、体重、姓名、性别等，通过这些信息就可以描述这个人，那描述HDFS上真实数据的信息，就称为元数据。 4.HDFS运行原理（重点） NameNode启动 将FsImage文件内容加载到内存中 执行EditLog文件的各项操作，使得内存的元数据和实际的同步 得到新的FsImage并创建一个空的EditLog文件 启动后所有的操作都记录在EditLog，并不会添加在FsImage中 DataNode启动 SecondaryNameNode启动 FsImage：维护文件系统树以及文件树中所有的文件和文件夹的元数据，但不维护块在哪个DataNode（通过NameNode与DataNode实时沟通生成文件目录并储存在内存中），主要记录文件复制等级、修改和访问时间、访问权限、块大小等 EditLog：操作日志文件，记录所有针对文件的增删改查等操作 通过FsImage和EditLog的结合就能完成所有文件的增删改查，但随着文件的修改EditLog会变得非常庞大，这时候就需要通过SecondaryNameNode来解决。 4.1 NameNode运行机制 1.SecondaryNameNode会定期和NameNode通信，请求暂停使用EditLog文件，暂时将新的操作写在新的文件EditLog.new上且瞬间完成。 2.SecondaryNameNode通过HTTP GET方式从NameNode上获取FsImage和EditLog并下载到本地。 3.SecondaryNameNode将下载的FsImage载入内存并与EditLog进行合并 4.SecondaryNameNode通过post方式将新的FsImage发送给NameNode 5.NameNode将新的FsImage替换掉，同时将EditLog.new替换成EditLog 4.2 HDFS思维导图凑合着看，别问为什么是个图片，问就是没钱^_^ 三、HDFS实操1.安装虚拟机这里强烈推荐一个微信公众号管家课堂，为数不多的超良心公众号，各种常用软件安装教程。这是一个安装传送门，记得关注哟 2.安装Linux并安装Hadoop我已经将配置好的Centos6打包好了网盘链接，提取码:cpj1 [当然爱折腾的可自行下载、配置、安装]。 解压下载好的安装包，打开VMware虚拟机，点击文件-&gt;打开（快捷键Ctrl + O），找到刚才解压的路径打开linux01虚拟机配置即可 出现该提示点击我已移动该虚拟机，无需其他操作等待加载完成即可 该虚拟机用户名如下，要使用root账户[权限高] 用户1：admin 密码：123456 用户2：root 密码：123456 如下即为Centos6的桌面 从PC机文件上传到虚拟机并不容易，因此我们使用SSH远程连接Linux，这里我使用MobaXterm。首先我们需要获取这个Linux的IP地址，右击桌面点击在终端打开输入 ifconfig 框选出来的就是本机IP，打开MobaXterm-&gt;Session-&gt;SSH输入刚才得到的IP即可， 第一次连接需要输入root用户的密码，注：Linux为保护用户安全，在你输入密码时屏幕并不会出现任何符号。 黑色背景区域即为Linux终端，一般使用Lin系统是不会选择启动图形化界面的。左边文件夹区域为Linux的文件系统，当需要将PC机文件上传到Linux时，只需拖拽即可。 这个Linux系统已经集成了Hadoop，不需要额外安装。 3.HDFS常见操作命令首先需要修改一下配置，输入 vi /etc/hosts 按i，将最后一行的IP修改为自己的，按Esc退出修改模式并输入 :wq 保存并关闭，上述只是Linux系统的操作命令，在我另一篇文章会有详细介绍，并且Hadoop的一些命令和Linux及其一致。 启动HDFS start-dfs.sh 启动完成可查看当前进程检查HDFS是否全部启动，输入如下代码 jps 当看到NameNode、DataNode、SecondaryNameNode即为启动成功 若有没有启动的可以结束HDFS并在此启动，代码如下 stop-dfs.sh start-dfs.sh 查看当前HDFS文件 hdfs dfs -ls / 在HDFS新建文件夹 hdfs dfs -mkdir /Test //在根目录下创建Test文件夹 删除HDFS指定文件(夹) hdfs dfs -rm -f /Test //删除指定文件夹 hdfs dfs -rm /name.txt //删除指定文件 将Linux文件上传到HDFS上 hdfs dfs -put /MapReduce/test.txt /Data 第一个路径为Linux要上传文件的绝对路径，第二个为上传到HDFS的路径（上述代码不要直接复制，因为你的Linux和HDFS可能没有这个文件夹和文件） 将HDFS文件下载到Linux本地 hdfs dfs -get /Data/text /MapReduce 同理第一个路径为HDFS要下载文件的绝对路径，第二个为下载到Linux本地的文件路径（Linux本地不能有与要下载文件同名的文件，道理很显然） 最后，关机命令（虚拟机上的系统很脆弱，要小心呵护不要暴力关机！！！） shutdown -h now 上述命令基本够用学习MapReduce了，期待下一遍博文将会详细介绍Hadoop另一个重要组件MapReduce 需要MobaXterm及其他技术支持联系微信^_^ skr~","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]},{"title":"My Thesis","slug":"My-Thesis","date":"2020-01-28T07:06:00.000Z","updated":"2020-01-29T01:47:49.810Z","comments":true,"path":"2020/01/28/My-Thesis/","link":"","permalink":"https://paperwj.top/2020/01/28/My-Thesis/","excerpt":"","text":"它来啦！它来啦！它终于来啦 久违的指导老师你终于在群里说话啦 ^__^ 指导老师：任务书已上传到实践教学系统，请大家及时查看。 并注意以下有关要求。 指导老师：毕业论文相关要求.docx 指导老师：2020届开题报告-模板.docx 指导老师：2020届毕业论文-模板.docx 指导老师：有啥不明白的，及时沟通。 直到今日，群里依旧是这些，我最想问的是：“老师我要写点什么？？？” 谦虚的我一直没有问，直到今天，偶尔看到了聊天记录的第一个词——“任务书…”，聪明的我终于知道我改写点什么了，可是…… My Task Book任务书 本毕业设计（论文）课题应达到的目的 灰色关联度分析(Grey Relational Analysis)是寻求系统中各子系统(或因素)之间数值关系的一种方法。灰色 关联度分析对于一个系统发展变化态势提供了量化的度量，非常适合动态(Dynamic)的历程分析。本课题将在分析灰 色关联度的基础上研究其在人才培养中的应用。通过对灰色关联度的相关应用讨论，加深对灰色关联度模型应用的理 解，拓宽学生的知识面。通过对本论文的撰写，使学生掌握基本的数学专业论文撰写方法，得到从事科学研究的初步 训练，学会基本的文献阅读、资料查阅方法，学会word文档排版方式，掌握基本的使用技巧。 这….说实话，每个字我都认识，可是怎么读起来这么诡异呢？？？度娘告诉我，这玩意是40年前咋国家的某教授提出的。（槽点一：一个才问世40年的理论知识就敢让我研究，不怕糟蹋了吗？？？） 百度的不解释，和舍友的任务书就只是换个一下关键词。 本毕业设计（论文）课题应达到的目的 通过广泛的文献阅读，掌握灰色关联度模型的主要内容，并能应用到人才培养中。通过查阅相关文献，深入了解灰 色关联度模型的内容及应用，撰写文献综述不少于2000字的开题报告，对本论文要完成的工作做一简要预测、阐 述。运用所学知识，借鉴参考文献研究问题的方法，对灰色关联度模型在人才培养中的应用提出自己的看法。撰写不低于10000字的论文。 工作要求： （1） 要求学生查阅有关文献资料，可通过上网和到图书馆等途径，完成资料的收集，并拟定论文提纲，按时保质保量地完成论文的写作。 （2）要求学生写论文过程中要积极主动、尽心尽力。 灰色关联度模型在人才培养中的应用，就是本次论文的题目啦！！！（槽点二：一会再说） 下面是我的参考文献 [1]肖筱南.现代信息决策方法[M].北京:北京大学出版社,2006:123-256. [2]刘思峰,郭天榜,党耀国.灰色系统理论及其应用(第二版)[M] .北京:科学出版社,1999. .. ... .... [17]史本广,程涛.基于灰关联分析的大学生成绩影响因素研究——以河南工业大学为例[J].河南工业大学学报(社会 科学版),2012,04:143-144,14. [18]Ding Jiantao.The Relations Study on Green Finance and Upgrading of Industrial Structure in China - Based on Grey Correlation Analysis Model[J].Advances in Social Science, Education and Humanities Research, 2019,volume 344:430-438. 注意[17]，我的导师在里面要给足面子。（接上面槽点：导师写过基本一样的论文，那我是不是修修补补就完事啦！！！然而…） 有请导师论文登场 Mentor Thesis放心，很快就能看完 What ! ! ! 这就是我一万字论文的支撑，Somebody save thesis 对本毕业设计（论文）课题成果的要求 论文中应包括本人对文献中所得到的结果的分析归纳结果，要在参考文献讨论的基础上进行必要的推广和创新，不得 抄袭他人的研究成果。撰写不低于文献综述不少于2000字的开题报告和不低于10000字的论文。 是不是忘了说什么…..这个重复率，啊，是吧！！！ 神秘代码 111001101000100010010001 111001101001100010101111 111001001011100010000000 111001001011100010101010 111001011010010010100111 111001011000001010111011 111010011000000010111100","categories":[{"name":"随想","slug":"随想","permalink":"https://paperwj.top/categories/随想/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://paperwj.top/categories/随想/"}]},{"title":"转载-20200201","slug":"转载-20200201","date":"2020-01-28T00:00:00.000Z","updated":"2020-02-03T08:05:21.649Z","comments":false,"path":"2020/01/28/转载-20200201/","link":"","permalink":"https://paperwj.top/2020/01/28/转载-20200201/","excerpt":"","text":"河南省教育厅关于进一步做好新型冠状病毒感染的肺炎疫情防控工作的紧急通知 各省辖市、济源示范区、省直管县（市）教育局，各高等学校，省属中等职业学校，厅直属学校： 鉴于新型冠状病毒感染的肺炎疫情防控形势严峻，为切实保障广大师生身体健康和生命安全，根据党中央、国务院关于疫情防控工作部署和我省启动重大突发公共卫生事件一级应急响应工作要求，现就有关工作通知如下： 一、全省各级各类学校和幼儿园推迟开学，具体开学时间视疫情形势另行通知。严禁任何学校（含公办、民办）擅自提前开学，正式开学前学生不得返校。任何学校不得组织高三、初三年级学生提前补课。各地教育部门和高等学校要根据疫情发展，科学研判，做好延迟开学预案，认真做好开学前的各项准备。 二、立即暂停各类校外培训机构所有线下课程和集体活动，恢复时间根据疫情防控工作情况另行通知。各地教育部门要会同市场监管等部门将相关要求及时传达到各培训机构，并做好监管工作。 三、全省各级各类学校和幼儿园要面向离校师生，通过微博、微信公众号、班级群等网络渠道，向学生和家长宣传普及疫情防治知识和防控要求，引导学生特殊时期不离家、不返校。要“一校一策”研究制定延期开学期间工作举措，根据实际调整教学计划，提供网上学习课程，指导学生安排好在家的学习和生活，并做好答疑和指导。 四、2020年我省普通高校招生艺术专业省统考音乐和舞蹈类面试延期进行，具体开考时间视疫情形势另行通知。 五、河南省高校毕业生就业市场原定于2020年2月份举办的系列双选活动推迟举办，具体举办时间视疫情形势另行通知 关于推迟举办河南省高校毕业生就业市场2020年2月份系列双选活动的通知各用人单位和求职者： 为切实保障广大招聘者及求职者身体健康和生命安全，根据党中央、国务院关于应对新型冠状病毒感染的肺炎疫情防控工作部署和省委、省政府启动突发公共卫生事件Ⅰ级应急响应工作要求，贯彻落实《河南省新型冠状病毒感染的肺炎疫情防控指挥部关于暂停举办大型公众聚集性活动的通知》精神，河南省高校毕业生就业市场原定于2020年2月份举办的系列双选活动将推迟举办，具体举办时间另行通知。衷心感谢广大用人单位及求职者对河南省高校毕业生就业市场的理解和支持。 为方便广大用人单位和求职者双选交流，河南省高校毕业生就业市场将依托河南省毕业生就业信息网（hnbys.haedu.gov.cn）及微信公众号（hnsbys）举办系列网上双选活动，帮助大家足不出户实现网上精准双选对接。 转自： 河南工业大学公众号","categories":[{"name":"转载","slug":"转载","permalink":"https://paperwj.top/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"https://paperwj.top/categories/转载/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2020-01-01T14:16:01.000Z","updated":"2020-01-30T12:33:06.300Z","comments":true,"path":"2020/01/01/Hexo-Theme-Sakura/","link":"","permalink":"https://paperwj.top/2020/01/01/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: https://broccoli.uc.cn/apps/pneumonia/routes/index?uc_param_str=dsdnfrpfbivesscpgimibtbmnijblauputogpintnwktprchmt, title: 抗击肺炎, desc: 肺炎动态, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://paperwj.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://paperwj.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://paperwj.top/categories/技术/"}]}]}